	ORG	0x0DA
ARRSTART:	WORD	0x67A	; Позиция начала массива (введённой строки)
LIMIT:	WORD	0x7FD	; Последняя ячейка, отведённая массиву
ELEM:	WORD	?	; Текущая позиция в массиве
COUNTER:	WORD	?	; Счётчик, нужный, чтобы строка не вышла за дозволенные пределы
STOPWORD:	WORD	0x000D	; Стоп-символ
STOPFLAG:	WORD	0x0000	; Ячейка, фиксирующая обнаружение сторп-символа
START:	CLA		; Очистка аккумулятора
	LD	ARRSTART	; Загружаем адрес ячейки начала массива
	ST	ELEM	; Сохраняем ячейку начала массива как текущую
	NEG
	ADD	LIMIT	; Вычитаем из предела массива адрес его начала
	ST	COUNTER	; Сохраняем это значение как счётчик
CYCLE:	NOP		; Точка отладки
	PUSH		; Оставляем в стеке "свободное" место под результат чтения
	CALL	READ	; Вызов подпрограммы для чтения с ВУ-3
	POP		; Загружаем считанный символ
	SWAB		; Перемещаем этот символ в старший байт
	ST	(ELEM)	; Сохраняем в массив
	CALL	CHECK	; Вызов подпрограммы проверки стоп-флага
	PUSH		; Оставляем в стеке "свободное" место под результат чтения
	CALL	READ	; Вызов подпрограммы для чтения с ВУ-3
	POP		; Загружаем считанный символ
	ADD	(ELEM)	; Прибавляем предыдущий символ
	ST	(ELEM)+	; Сохраняем в массив оба символа и инкрементируем адрес
	CALL	CHECK	; Вызов подпрограммы проверки стоп-флага
	NOP		; Точка отладки
	LOOP	COUNTER	; Если место под строку кончилось, то выходим, иначе продолжаем цикл
	JUMP	CYCLE	; Цикл
FINISH:	HLT		; Останов
READ:	IN	7	; Запрос статусного регистра ВУ-3
	AND	#0x40	; Маска для  6-го бита
	BEQ	READ	; spin-loop, если не готов, то снова проверяем статус, иначе продолжаем
	IN	6	; Считывание введённого символа
	NOP		; Точка отладки
	CMP	STOPWORD	; Сравнение со стоп-символом
	BNE	RETURN	; если не совпало, то возвращаемся
	ST	STOPFLAG	; Установка стоп-флага
RETURN:	ST	&1	; Сохранение в стек считанного символа
	RET		; Возврат из подпрограммы
CHECK:	LD	STOPFLAG	; Загрузка стоп-флага
	BNE	FINISH	; Если стоп-флаг установлен, то выход из программы, иначе возврат
	RET		; Возврат из подпрограммы
